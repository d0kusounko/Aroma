//===========================================================================
//!
//!	@file		FixedArray.h
//!	@brief		初期化時に動的メモリ確保を行う固定長配列.
//!
//!	@author		Copyright (C) DebugCurry. All rights reserved.
//!	@author		d0
//!
//===========================================================================
#pragma once

#include <memory>

namespace aroma {
namespace data {

//---------------------------------------------------------------------------
//!	@brief	動的メモリ確保を行う固定長配列クラス.
//!
//! @details
//!		std::arrayのサイズ定義をコンストラクタで行う版.
//---------------------------------------------------------------------------
template< class T >
class FixedArray
{
public:
	using SizeType = size_t;

public:

	//---------------------------------------------------------------------------
	//!	@brief		コンストラクタ.
	//!
	//!	@param[in]	bufSize		バッファサイズ(要素数).
	//---------------------------------------------------------------------------
	explicit FixedArray( SizeType bufSize )
		: m_bufSize( bufSize )
		, m_Buf()
	{
		CreateBuffer();
	}

	//---------------------------------------------------------------------------
	//! @brief		コピーコンストラクタ.
	//!
	//! @param[in]	obj	コピー元.
	//!
	//! @details
	//!		コピー元と同サイズのバッファを確保して内容をコピーします.
	//---------------------------------------------------------------------------
	explicit FixedArray( const FixedArray< T >& obj )
	: m_bufSize(obj.m_bufSize)
	, m_Buf()
	{
		CreateBuffer();
		Memcpy( data(), obj.data(), sizeof( T ) * m_bufSize );
	}

	//---------------------------------------------------------------------------
	//!	@brief		デストラクタ.
	//---------------------------------------------------------------------------
	~FixedArray() {}

	//---------------------------------------------------------------------------
	//!	@brief		バッファの取得.
	//---------------------------------------------------------------------------
	T* data() { return m_Buf.get(); }
	const T* data() const { return m_Buf.get(); }

	//---------------------------------------------------------------------------
	//! @brief		バッファサイズの取得.
	//---------------------------------------------------------------------------
	SizeType size() const { return m_bufSize; }

	//---------------------------------------------------------------------------
	//! @brief		n番目の要素を参照(境界チェックあり).
	//!
	//! @param[in]	n	添字.
	//!
	//! @return		要素の参照.
	//!
	//! @details
	//!		境界チェックを行います.
	//!		境界外の要素を参照しようとした場合は例外をスローします.
	//---------------------------------------------------------------------------
	T& at( SizeType n )
	{
		if( n >= size() )
		{
			throw std::out_of_range( "Out of range." );
		}
		return m_Buf[ n ];
	}
	const T& at( SizeType n ) const
	{
		if( n >= size() )
		{
			throw std::out_of_range( "Out of range." );
		}
		return m_Buf[ n ];
	}

	//---------------------------------------------------------------------------
	//! @brief		先頭要素を参照.
	//!
	//! @return		先頭要素の参照.
	//---------------------------------------------------------------------------
	T& front() { return m_Buf[0]; }
	const T& front() const { return m_Buf[0]; }

	//---------------------------------------------------------------------------
	//! @brief		末尾要素を参照.
	//!
	//! @return		末尾要素の参照.
	//---------------------------------------------------------------------------
	T& back() { return m_Buf[m_bufSize - 1]; }
	const T& back() const { return m_Buf[m_bufSize - 1]; }

	//===========================================================================
	//! @name	operator群.
	//===========================================================================
	//! @{
	//---------------------------------------------------------------------------
	//! @brief		代入演算子.
	//---------------------------------------------------------------------------
	const FixedArray& operator = ( const FixedArray<T>& rhs )
	{
		m_bufSize = rhs.size();
		CreateBuffer();
		Memcpy( data(), rhs.data(), sizeof( T ) * m_bufSize );

		return *this;
	}

	//---------------------------------------------------------------------------
	//! @brief		インデックスアクセス.
	//!
	//! @param[in]	n	添字.
	//!
	//! @return		要素の参照.
	//!
	//! @details
	//!		境界チェックは行わないので, 行う場合はat()を使用して下さい.
	//---------------------------------------------------------------------------
	T& operator[]( SizeType n ) { return m_Buf[n]; }
	const T& operator[]( SizeType n ) const { return m_Buf[n]; }

	//! @}

private:
	//! バッファ生成.
	void CreateBuffer()
	{
		m_Buf.reset( new T[ m_bufSize ] );
	}

private:
	SizeType				m_bufSize;	//!< バッファサイズ.
	std::unique_ptr<T[]>	m_Buf;		//!< データバッファ.
};

} // namespace data
} // namespace aroma
